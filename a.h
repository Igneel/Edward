// поиск А* в реальном времени с обучением
// Н - текущая наилучшая оценка стоимости достижения цели
// из каждого состояния, которое уже было посещено 
// WorldSize - размер мира, константа.

#include "motor.h"
#include "SafeDriving.h"


// константы задержки, при перемещении между состояниями и при проверке состояния.
const short DELAY_TIME_VR_10=64; // время поворота на 10 градусов
const short DELAY_TIME_1sm=71;  // задержка на 1 см
const short SPEED=255;

const short WorldSize=30;
int maxX=0;
int maxY=0;

const int dX=2; // смещение центра вращения робота относительно дальномера
const int dY=4;

// текущее положение робота определяют относительные координаты и вектор направления
// cX cY direction
int cX=0;
int cY=0;
// насчет энума ещё подумать - в зависимости от датчиков
enum direction {UP=1,RUP=2,RIGHT=3,RDOWN=4,DOWN=5, LDOWN=6,LEFT=7,LUP=8,ZEROD=9};
enum direction cdirection=1;  // начально направление - вверх


short cxx=0,cyy=0; // сюда будет записываться прибавка к текущим координатам
char string[16];
char delimiter[16];

char strint[5]={0};
//------------------------------------------------------------------------------
//---------------Прототипы функций----------------------------------------------

 void SRotare(enum direction d,enum direction nd); // поворот
 short isMetall();               // возвращает 1 если предмет металлический
 short comp(short d1,short d2); // сравнение двух чисел
 short SMove(short nx,short ny); // перемещение
 int Cost();              // определение стоимости
 void A_search();         // алгоритм поиска A*
 void Brain();             // эвристика
 void Correct(void);     // коррекция движения
 
 
 // для работы с блютузом:
 int getParam(const char * p,int x,int y);
 void setParam(const char * p,int x,int y,int value);
 void strConstCpy (const char *source, char *dest);
//------------------------------------------------------------------------------

// Процедура копирования строки из ROM в RAM
void strConstCpy (const char *source, char *dest) {
 while (*source) *dest++ = *source++;
 *dest = 0;
}
void stradd(char *source, char *dest){
while (*dest++);
*dest--;
while (*source) *dest++ = *source++;
 *dest = 0;
}
// "Hint" Для H и "hevr" для эвристики
int getParam(const char * p,int x,int y)
{
 char temp=0;
 strConstCpy(p,string); // копируем код команды
 IntToStr (x,strint);
 stradd(strint,string);
 IntToStr (y,strint);
 stradd(strint,string);
 stradd("   ",string);
 UART1_Write_Text(string);
 while(1) if(UART1_Data_Ready()) // ждем ответ
 {
 temp=UART1_Read();
 return temp;
 }
}

 void setParam(const char * p,int x,int y,int value)
 {
 char temp=0;
 strConstCpy(p,string); // копируем код команды
 IntToStr (x,strint);
 stradd(strint,string); // копируем первую координату
 IntToStr (y,strint);
 stradd(strint,string); // копируем вторую координату
 IntToStr (value,strint);
 stradd(strint,string);
 stradd("   ",string);    // дописываем символ пробела в конец строки
 UART1_Write_Text(string); // отправляем данные
 while(1) if(UART1_Data_Ready()) // ждем ответ
 {
 temp=UART1_Read();
 return;
 }
 }

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
short isMetall()
{
short m;
m=Adc_Rd(1);
if(m>0 && m<50)
return 1;    // если объект металлический возвращаем единицу
else
return 0;
}
// функция для сравнения, возвращает три возможных значения +1,0,-1
short comp(int d1,int d2)
{
        if(d1==d2) return 0; // операнды равны
        if(d1>d2) return 1; // первый больше второго
        else return -1; // первый меньше второго
}
// перемещение надо указать направление и новые координаты
// направление - глобальная переменная
short SMove(int nx,int ny)
{

        enum direction nd=1; // относительное направление движения
        short ax=1;
        short ry=1;
        short isMove=0; // индикатор - было ли движение
        ax=comp(cX,nx);  // сравниваем текущие координаты с заданными
        ry==comp(cY,ny);
        // в зависимости от результатов - определяем нужное направление
        if(ax==-1)  // если нам нужно направо
                nd=RIGHT+ry;
        if(ax==0)    // смещаться по оси х не нужно
                switch(ry)
                {
                        case -1: //
                                nd=UP;
                        break;
                        case 0:
                        nd=ZEROD;
                        // мы уже находимся в нужном месте
                        break;
                        case 1:
                                nd=DOWN;
                        break;

                }
        if(ax==1)   // если нам нужно налево
                nd=LEFT-ry;
        // мы определили новое направление, теперь нужно переместиться.
        //getParam("swNd",nd,1);
        switch (nd)
        {
        case 1:
        case UP:
        if(isSafeY()>2)
        {
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_FWD(); // запускаем моторы
        Motor_B_FWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        Correct();
        isMove=1;
        }
        break;
        case 2:
        case RUP:
        if(isSafeY()>2 && isSafeX()>2)
        {
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_FWD(); // запускаем моторы
        Motor_B_FWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        }
        break;
        case 3:
        case RIGHT:
        if(isSafeX()>2)
        {
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_BWD(); // запускаем моторы
        Motor_B_BWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_FWD(); // запускаем моторы
        Motor_B_FWD();
        delay_ms(3*DELAY_TIME_1sm); // ждем пока приедем  -------------------------------------------------------------------------------------------------
        Motor_Stop();
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        }
        break;
        case 4:
        case RDOWN:
        if(isSafeX()>2)
        {
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_BWD(); // запускаем моторы
        Motor_B_BWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        }
        break;
        case 5:
        case DOWN:
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_BWD(); // запускаем моторы
        Motor_B_BWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        Motor_Init();
        Correct();
        isMove=1;
        break;
        case 6:
        case LDOWN:
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_BWD(); // запускаем моторы
        Motor_B_BWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        break;
        case 7:
        case LEFT:
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_BWD(); // запускаем моторы
        Motor_B_BWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_FWD(); // запускаем моторы
        Motor_B_FWD();
        delay_ms(3*DELAY_TIME_1sm); // ждем пока приедем ----------------------------------------------------------------------------------------------
        Motor_Stop();
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        break;
        case 8:
        case LUP:
        if(isSafeY()>2)
        {
        S_Left(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Motor_Init();  // настраиваем моторы
        Change_Duty(SPEED); // задаем скорость
        Motor_A_FWD(); // запускаем моторы
        Motor_B_FWD();
        delay_ms(2*DELAY_TIME_1sm); // ждем пока приедем
        Motor_Stop();
        S_Right(255);
        delay_ms(DELAY_TIME_VR_10*15/10);
        Correct();
        isMove=1;
        }
        break;
        case 9:
        case ZEROD:
        getParam("zerod",1,1);
        break;
        }
        
        
         if(isMetall()) // проверяем есть ли тут монетка
         {
         // передаем сигнал о том что тут монетка
         if(isMove)
         setParam("Metall",nx,ny,1);
         }
         return isMove;    // сообщаем было ли движение

}

// вращение, использует текущее направление и новое

void SRotare(enum direction d,enum direction nd)
{
int xa=0;
int ya=0;
int temp=0;
short r=0;
xa=cX;
ya=cY;


        r=(d-nd);
        if(r>4) r=8-r; // если угол поворота больше 180 - будем поворачитьвася в другую сторону
        if(r>=0)
        {       ;
                S_Right(255); // поворачиваемся по наименьшему пути
                for(;r>0;r--)
                {
                Delay_ms(DELAY_TIME_VR_10*45/10);
                if(r%2==1) continue;
                switch(cdirection)
                {
                case UP:
                  xa=cY;
                  ya=-dX+cX;
                break;
                case DOWN:
                  xa=cY;
                  ya=cX+dY;
                break;
                case RIGHT:
                  xa=cY;
                  ya=-2*dX+cX;
                break;
                case LEFT:
                  xa=cY;
                  ya=cX+dX;
                break;
                }
                }
        }
        else
        {
                S_Left(255);
                for(;r<0;r++)
                {
                Delay_ms(DELAY_TIME_VR_10*45/10);
                if((-r)%2==1) continue;
                switch(cdirection)
                {
                case UP:
                  xa=cY-2*dY;
                  ya=cX;
                break;
                case DOWN:
                  xa=cY;
                  ya=2*dX+cX;
                break;
                case RIGHT:
                  xa=cY;
                  ya=cX+dY;
                break;
                case LEFT:
                  xa=cX+dX;
                  ya=cX;
                break;
                }
                }
        }
        Motor_Stop();
cdirection=nd;
cX=xa;
cY=ya;
}


void Correct(void) // корректирует направление робота
{
short r,nr;
r=isSafeY();                // проверить расстояние
S_Left(DELAY_TIME_VR_10);  // повернуться
nr=isSafeY();               // проверить расстояние
if(r==nr)                   // сравнить их, если получаем правильное соотношение
S_Right(DELAY_TIME_VR_10);  // то мы находимся в правильном положении
if(r>nr)
return;
if(r<nr)
S_Right(2*DELAY_TIME_VR_10);
Motor_Stop();
}



// непосредственно сам поиск
void A_search()
{
        //int i,j;
        int min,temp;
        //if(getParam("jobisdone?",1,1)==13) return; // если база говорит что работа окончена - завершаем работу.
        
        temp=getParam("Hint",cX,cY); // получаем значение стоимости для текущего состояния

        setParam("Hint",cX,cY,++temp); // увеличиваем его, т.к. мы уже здесь
        // оцениваем перспективность доступных состояний
        /*min=getParam("H+hevr",cX,cY+1);
        cxx=0;
        cyy=1;
        for(i=-1;i<=1;i++) // у нас в любом состоянии 8 возможных действий
        {
           for(j=-1;j<=1;j++)//----------------------------------------------------------------------------------------------------------------------!!!!!
              { // анализируем все возможные состояния и находим состояние
                  if(i==0 && j==0) continue;
                  temp=getParam("H+hevr",cX+i,cY+j);
                  if(temp<min) // имеющее минимальную стоимость
                  {            // а значит ближайшее к цели
                     min=temp;
                     cxx=i;
                     cyy=j;
                  }
              }
        }   */
        cxx=getParam("Calc",cX,cY);
        cyy=getParam("Calc2",cX,cY);
              if(cdirection==UP) ;
              if(cdirection==DOWN) cyy*=-1 ;
              if(cdirection==LEFT)
              {
              temp=cxx;
              cxx=cyy;
              cyy=-temp; 
              }
              if(cdirection==RIGHT)
              {
              temp=cxx;
              cxx=cyy;
              cyy=-temp;
              }
        if(SMove(cX+cxx,cY+cyy)) // перемещаемся в выбранное состояние
        {
        
        cX+=cxx; // обновление текущих координат
        cY+=cyy;
        }
        // если перемещения не произошло, то робот вряд ли выберет тот же путь
        // так как его стоимость теперь увеличилась

}

// функция взятия модуля от числа
 short mod(short x)
 {
 if(x>=0) return x;
 else return -x;
 }
// функция заполнения эвристической оценки h надо перенести на комп
void Brain()
{
        short x,y,j,k;
        short r;
        // на момент вызова функции цели должны быть определены
        for(x=0;x<WorldSize;x++)
        {
        for(y=0;y<WorldSize;y++)
        {
        if(getParam("Hint",x,y)/*H[x][y]*/!=0) continue; // если значение не нулевое- значит мы там были и всё нашли.
        for(j=0;j<WorldSize;j++) // x
         for(k=0;k<WorldSize;k++) // y
             {
             r=mod(x-j)+mod(y-k);  // манхетенское расстояние
             if(r<getParam("hevr",j,k)) setParam("hevr",j,k,r); //h_evr[j][k])  // h_evr[j][k]=r; // если есть цель ближе - запишем расстояние до неё
             }
        }
        }
}